# Linux 的线程调度算法及调度模型

以前学习操作系统时感觉是在背书，现在看来是做了大量的无用功，从新好好学一下。

传统的线程调度算法有`SJF(短作业优先)`，`SRTN(最短剩余时间优先)`, `HRRN(最高响应比优先)`, `RR(轮转)`, `HPF(优先级)`等等。但是我都不知道哪些系统用这些算法，所以学起来也没效率。

## 单核调度

最新的调度算法称为 CFS。

设定一个调度周期（*sched_latency_ns*），目标是让每个进程在这个周期内至少有机会运行一次。

分配给进程的运行时间 = 调度周期 * 进程权重 / 所有进程权重之和 (公式1)

vruntime = 实际运行时间 * 1024 / 进程权重 。 (公式2)

nice 值对应的权重转换：

```cpp
nice值共有40个，与权重之间，每一个nice值相差10%左右。
static const int prio_to_weight[40] = {
    /* -20 */ 88761, 71755, 56483, 46273, 36291,
    /* -15 */ 29154, 23254, 18705, 14949, 11916,
    /* -10 */ 9548, 7620, 6100, 4904, 3906,
    /* -5 */ 3121, 2501, 1991, 1586, 1277,
    /* 0 */ 1024, 820, 655, 526, 423,
    /* 5 */ 335, 272, 215, 172, 137,
    /* 10 */ 110, 87, 70, 56, 45,
    /* 15 */ 36, 29, 23, 18, 15,
};
```

> 举例就是在 nice 为0时，实际运行时间=vruntime，在大概-9左右 实际运行时间比如是 a单位 换算为 vruntime 则为 （a/10）单位 

每个任务分配的具体比例是根据 nice 值来计算的。nice 值的范围从 -20 到 19，数值较低的 nice 值表示较高的优先级。具体较低 nice 值的任务，与具有较高 nice 值的任务相比，会分配更高比例的处理器处理时间。默认 nice 值为 0.

有了vruntime的概念后，调度算法就非常简单了，谁的vruntime值较小就说明它以前占用cpu的时间较短，受到了“不公平”对待，因此下一个运行进程就是它。这样既能公平选择进程，又能保证高优先级进程获得较多的运行时间。这就是CFS的主要思想了。

具体实现中，Linux 采用一颗红黑树，记录下每一个进程的 vruntime，通过比较vruntime，来实现下一个需要运行的进程，

#### 如果新来一个进程那么 vruntime 为 0 的话，可能会抢占 cpu 很久？（并不）

每个 CPU 维护一个 min_vruntime 字段，记录该运行队列中所有进程的 vruntime 最小值，新进程的最初 min_vruntime 设置的。

#### 休眠进程唤醒后vruntime 会差很多吗？

CFS是这样做的：在休眠进程被唤醒时重新设置vruntime值，以min_vruntime值为基础，给予一定的补偿，但不能补偿太多。

#### 时间片？

CFS设定了进程占用CPU的最小时间值，*sched_min_granularity_ns*，正在CPU上运行的进程如果不足这个时间是不可以被调离CPU的。

## 多核调度

所谓多核调度，就是每个CPU有一个run queue（下面简称rq），创建线程（下面简称task）的时候把线程扔到一个rq中，那个CPU就对这个rq执行单核的调度算法而已。

当然，那个仅仅是基础。多核调度还有一个任务是平衡调度。就是一个核特别忙，另一个核特别闲，就需要把task从一个核迁移到另一个核的runqueue中。

可调优方案：

1. 通过ftrace跟踪sched:sched_migrate_task跟踪任务转移的频度

2. 把老切换的任务绑定在特定的核上

#### 进程从一个 CPU 迁移到另一个 CPU？

如果一个进程从min_vruntime更小的CPU (A) 上迁移到min_vruntime更大的CPU (B) 上，可能就会占便宜了

CFS是这样做的：
当进程从一个CPU的运行队列中出来 (dequeue_entity) 的时候，它的vruntime要减去队列的min_vruntime值；
而当进程加入另一个CPU的运行队列 ( enqueue_entiry) 时，它的vruntime要加上该队列的min_vruntime值。

