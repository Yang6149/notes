# 用户态进入内核态

1. 用户态调用操作系统提供的接口
2. 在eax寄存器存入这次的系统调用的编号
3. 调用int $0x80的汇编指令，发送中断指令
4. 在中断描述符表中根据这个指令找到system_call()所在的内核空间地址
5. system_call()通过eax寄存器得知进行哪项操作

![1591800241531](https://raw.githubusercontent.com/Yang6149/typora-image/master/demo/202006/10/224402-963835.png)

当程序中有系统调用语句，程序执行到系统调用时，首先使用类似int 80H的软中断指令，保存现场，去的系统调用号，在内核态执行，然后恢复现场，每个进程都会有两个栈，一个内核态栈和一个用户态栈。当执行int中断执行时就会由用户态，栈转向内核栈。系统调用时需要进行栈的切换。而且内核代码对用户不信任，需要进行额外的检查。系统调用的返回过程有很多额外工作，比如检查是否需要调度等。