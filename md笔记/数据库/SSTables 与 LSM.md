# SSTables 与 LSM

## SSTables

### 概述

以前我们存储文件数据要不就是简单的顺序写、hash映射偏移要不就是B树，在连续的空间中文件中的键值对的顺序似乎并不重要。

现在做个简单的改变，文件中的键值对按键排序。我们把这种格式称为 排序字符串表 Sorted String Table。我们还要求每个键只在存在一次(压缩)

好处：

1. 合并段高效。直接归并排序，轻易实现大文件合并(顺序写)。
2. 查找：由于是排好序的可以二分搜索或根据其他键进行偏移(类似跳表结构的索引)。
3. 可以根据块分组，索引指向每个压缩块。



## LSM 

### 维护LSM

- 写入时将其添加到内存中的平衡树(如红黑树).这个内存树可被称为内存表。
- 当内存表大于阈值时，将其按照SSTable结构写入磁盘。这可以高效完成，因为是顺序写。
- 读请求首先尝试在内存表中找，找不到再找磁盘。
- 后台运行合并压缩Segment以及丢弃覆盖值。

### 缺点

1. 有个内存表，可能会因为系统崩溃而丢失。

解决办法：写日志，每次操作都写进去。当内存表中数据写入磁盘时就丢弃日志。

2. 一层层的在level上查找，效率低

解决办法：可以先有一层缓冲层，按照LRU缓存在内存上。

可以为每一个level设计一个布隆过滤器。

把以上几个特点结合起来就是LevelDB LSM中的结构

它分为两个区：

1. 常驻内存的树：由红黑树、跳表、b树实现
2. 常驻磁盘的结构：由SSTable实现。

![1592736877832](https://raw.githubusercontent.com/Yang6149/typora-image/master/demo/202006/21/185439-343022.png)

可以有多个层级减少了每次合并的开销，只有在最深层合并才会开销最大。

特点：

1. 写入性能高
2. 每个SSTable 都是不可修改的，只有最上层的memcache需要设计锁

# B树 VS LSM

速度：

* B树可以支持读多操作

* LSM可以支持写多操作

大小：

* B树经常页面拆分，数据占不满整个页。
* LSM文件紧凑，空间占用更小

**缺点**：

写放大：写入数据库导致多次磁盘的写入。比如SSTables多次融合。

写入空数据库时，可以使用全磁盘带宽进行初始写入，但数据库越大，压缩所需的磁盘带宽就越多。