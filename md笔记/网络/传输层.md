### 传输层

网络层只把分组发送到目的主机，但是真正通信的并不是主机而是主机中的进程。传输层提供了进程间的逻辑通信，传输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看起来像是在两个传输层实体间有一条端到端的逻辑通信信道。

## UDP 和 TCP 的特点

* 用户数据报协议 UDP （User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面对报文（对于应用程序传下来的报文不合并页不拆分，只是添加 UDP 首部），支持一对一，一对多，多对一和多对多的交互通信。
* 传输控制协议 TCP （Transmission Control Protocol）是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面对字节流（应用层把传下来的报文堪称字节流，把字节流组织成大小不等的数据块），每一条 TCP 链接只能是点对点的（一对一）。

## UDP 首部格式

![](https://img-blog.csdnimg.cn/20190317180857605.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1d1MDAwOTk5,size_16,color_FFFFFF,t_70)

首部字段只有 8 个字节，包括端口、目的端口、长度、校验和。 12 字节的伪首部

## TCP 首部格式

![](https://img-blog.csdnimg.cn/2019031717512915.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1d1MDAwOTk5,size_16,color_FFFFFF,t_70)

* 序号：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应该为 401.
* 确认号：期待收到的下一个报文段的序号。 例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。 
* 数据偏移：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。
* 确认 ACK：当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置1。
* 同步 SYN：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方统一建立连接，则响应报文中 SYN=1，ACK=1。
* 终止 FIN：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已经发送完毕，并要求释放连接。
* 窗口：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。

状态码：SYN表示建立连接，

FIN表示关闭连接，

ACK表示响应，

PSH表示有 DATA数据传输，

RST表示连接重置。

## TCP 的三次握手

![](https://img-blog.csdn.net/20180717202520531?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4OTUwMzE2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

假设 A 为客户端，B 为服务器端。

* 首先 B 处于 ：LISTEN （监听）状态，等待客户的连接请求。
* A 向B发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号x。
* B 收到连接请求报文，如果统一建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为x+1，同时也选择一个初始的序号y。
* A 收到 B 的连接确认后，还要向 B 发出确认，确认号为 y+1，序号为 x+1.。
* B 收到 A 的确认后，连接建立

### 三次握手的原因

本质是两次请求两次确认。某种情况下是四次握手。



## TCP 的四次挥手

![](https://img-blog.csdn.net/20180717204202563?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4OTUwMzE2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

以下描述不再讨论序号和确认号，因为序号和确认号。并且不讨论 ACK，因为确认建立之后的 ACK 都是 1。

* A 发送连接是释放报文，FIN=1。
* B接收到之后发出确认，此时 TCP 处于半关闭状态，B 能像 A 发送数据，A 不能向 B 发送数据。
* 当 B 不再需要连接时， 发送连接释放报文，FIN=1。
* A 接收到信息之后发出确认，进入TIME-WAIT状态，等待2 MSL（最大报文存活时间）后释放连接。
* B 收到 A 的确认后释放连接。

### 四次挥手的原因

客户端发送 FIN 连接释放报文之后，进入FIN-WAIT状态，服务器端进入CLOST-WAIT状态，这个状态是为了让服务器端把还没发送完的数据发送完，发送完之后发送一个 FIN 连接释放报文。

TIME-WAIT

客户端接收到服务器发送的 FIN 连接释放报文后会进入 TIME-WAIT 状态，而不是直接进入 CLOSE 状态，进入一个 2 MSL 的计时，原因有：

* 确保最后一个确认报文能够到达。如果服务器端没有收到客户端发送来的确认报文的话，会重复发送连接释放报文，客户端等待的这一段时间就是为了处理这种情况。
* 等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。

## 有限状态机

 ![1592209407859](https://raw.githubusercontent.com/Yang6149/typora-image/master/demo/202006/15/162330-767436.png) 

## TCP 可靠传输

TCP 使用超时重传来实现可靠传输：如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。

一个报文段从发送再到接收到确认所经过的时间称为往返 RTT，加权平均往返时间 RTTs 计算如下：



其中，0 ≤ a ＜ 1，RTTs 随着 a 的增加更容易受到 RTT 的影响。

超时时间 RTO 应该略大于 RTTs，TCP 使用的超时时间计算如下：

RTO=RTTs+4*RTTd

其中 RTTd 为偏差的加权平均值。

## TCP 滑动窗口

窗口时缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其他信息设置自己的窗口大小。

发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已经发送并且已确认状态；接收窗口的滑动窗口类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。

接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为{31，34，35}其中{31}按序到达，而{34，35}就不是，因此只对字节 31 进行确认。发送方得到一个字节的确认之后，就直到这个字节之前的所有字节都已经被接收。

## TCP 流量控制

流量控制是为了控制发送方发送速率，保证接收方来得及接收。

接收方发送的确认报文中的窗口字段可以用来控制发送窗口大小，从而影响发送方的发送频率。将窗口字段设置为 0，则发送方不能发送数据。

## TCP 拥塞控制

如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。



TCP主要通过四个算法来进行拥塞控制：满开始、拥塞避免、快重传、快恢复。

发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。

为了便于讨论，做如下假设：

* 接收方有足够大的接收缓存，因此不会发生流量控制；
* 虽然 TCP 的窗口基于字节，但是这里设窗口的大小单位为报文段。

![](https://camo.githubusercontent.com/ebaf2e593f47149d5c17b4770dcf9b5125ec316f/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f39313066363133662d353134662d343533342d383764642d3962343639396435396433312e706e67)

### 1. 满开始与拥塞避免

举例：

有一个 1 M 的文件，由于 MTU = 1500，所以把它切片成 每个 segment 1460，大约600+个，然后开始**慢开始**慢慢的 cwnd 大了，比如说这一次要发送 {5，6，7，8，9，10，11，12} 但是接收到{5，6}后接收到了{8}，这个时候不能确认是不是网络传输中 8 先到达而顺序错了，还是 7 丢失了，就先返回一个 ack= 7 的报文，然后如果下一次到的还不是 7 而是 9，就再发送一个 ack= 7，发送三次ACK一样的报文之后，就直接

发送的最初执行慢开始，令 cwnd = 1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8....

注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。设置一个满开始门限 ssthresh，当 cwnd >= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。

如果出现超时，则令 ssthresh = cwnd/2，然后重新执行满开始。

### 2. 快重传与快恢复



在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。

**在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时立刻执行快重传**，立即重传下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3。

在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。

慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。

![1581505655203](C:\Users\hasaki\AppData\Roaming\Typora\typora-user-images\1581505655203.png)

