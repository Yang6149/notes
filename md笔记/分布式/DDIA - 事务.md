# 事务

## 一、事务的棘手概念

### ACID 的含义

ACID代表原子性（**Atomicity**），一致性（**Consistency**），隔离性（**Isolation**）和持久性（**Durability**）。

但实际上，不同的数据库的 ACID 实现并不相同。例如，我们将会看到，围绕着隔离性（Isolation） 的含义有许多含糊不清。

> 不符合 ACID 的被称为 BASE 它代表基本可用性（**Basically Available**），软状态（**Soft State**）和最终一致性（**Eventual consistency**）

### 原子性（**Atomicity**）

两个线程在同时工作时，一个线程在进行原子操作，这意味着另一个线程只能看到它操作前和操作后的状态，看不到介于两者之间的状态。

在事务中体现在如果一些写操作被分组到一个原子事务中，并且该事务由于错误而不能完成（提交），则该事务将被中止，并且**数据库必须丢弃或撤消该事务中迄今为止所做的任何写入**。 

### 一致性（Consistency）

* 在主从复制的副本一致性中，不一致 表示的是主从上数据不能及时同步的问题
* 一致性Hash
* CAP 后面笔记会讲到（回头改）
* 这里的 ACID 表示应用程序处于良好状态。

**原子性、隔离性、持久性是数据库的属性。**

**一致性（ACID）是应用程序的一个属性**，可以通过数据库的原子性和隔离性属性来实现一致性，但这并不仅取决于数据库。

### 隔离性（Isolation）

ACID意义上的隔离性意味着，同时执行的事务是相互隔离的

### 持久性（Durability）

数据库系统的目的是，提供一个安全的地方存储数据，而不用担心丢失。

在带复制的数据库中，持久性可能意味着数据已成功复制到一些节点。为了提供持久性保证，数据库必须等到这些写入或复制完成后，才能报告事务成功提交。

## 二、单对象和多对象操作

在进行写入操作时数据库因该做的事情：

* 原子性：发生错误全部回滚
* 事务之间不能相互干扰。

假设同时修改多个对象。通常需要多对象事务（multiObject transaction）来保持多块数据同步。

在下面一个例子为电子邮件应用的例子，查看用户未读邮件数量

`SELECT COUNT（*）FROM emails WHERE recipient_id = 2 AND unread_flag = true `

那么可能遇到这种情况：用户看到列表里有显示未读消息，但是计数器显示未读消息为零。隔离性可以避免这个问题：确保用户同时只能看到新邮件和增长后的计数器，要么都看不到。

![1584515362602](https://raw.githubusercontent.com/Yang6149/typora-image/master/demo/202003/18/150922-599922.png)

以上图违反了隔离性，把User1、2看作两个事务，User 2 读取了User 1 还没提交的写入。

原子性可以确保发生错误前的内容全部回滚。

### 单对象写入

当单个对象发生改变时，原子性和隔离性也是适用的。有些数据库也提供了一些复杂的原子操作，如自增操作、CAS操作。

### 多对象事务的需求

许多分布式存储已经放弃了多对象事务，因为多对象事务很难跨分区实现，而且在需要高可用性或高性能的情况下，会很碍事。

在一些场景中，单对象插入，更新和删除时足够的。但是许多其他场景需要协调写入几个不同的对象：

* 在关系数据模型中，一个表中的行通常具有对另一个表中的行的外键引用。
* 在文档数据模型中，需要一起更新的字段通常在同一个文档中，这被视为但对象。如上图中，可以看作是文档，也就是一次更新多个文档。
* 在具有二级索引的数据库中，每次更改值都需要更新索引。

### 处理错误和终止

一般数据库事务发生错误时要求终止并 rollback，我们想要成功运行一个事务可以终止重试来完成，但并不完美：

* 事务已经成功，但是网络发生错误以为没成功。
* 如果负载过大造成事务失败，重试只能让事情变得更糟
* 由于临时性的网络中断，锁阻塞之类的问题造成的终止，重试很好。
* 有一种 2-phrase commit，在分区中的实现极其复杂并缓慢。
* 参考 spanner

## 三、隔离级别

如果两个事务不触及相同的数据，我们可以 parallel 的进行运行。但是两个事务想同时操作相同的数据，就会出现问题。

### Read Commited

1. 都数据时只能看到 commited 的数据（无脏读）
2. 写数据时会覆盖已经 commited 的数据（无脏写）

![1589559304290](https://raw.githubusercontent.com/Yang6149/typora-image/master/demo/202005/16/001504-238093.png)

以上情况位脏写。

保证 Read Commited 一般可以使用读写锁，行级锁实现。

### 快照隔离和Repeated Read

![1589559603250](C:\Users\hasaki\AppData\Roaming\Typora\typora-user-images\1589559603250.png)

不可重复读会引发的问题

**快照隔离**

这是一种最常见的解决方法，每个事务从数据库的一致快照中读取，如 MySQL 的 MVCC。

还有一种就是通过锁阻塞不同事务使用相同数据，不过效率很低就是了。

**但是可能出现幻读如：**

![1593965321112](https://raw.githubusercontent.com/Yang6149/typora-image/master/demo/202007/06/000848-829945.png)

### Serializable

1. 真串行

2. 2PL

3. SSI

   通过快照检查commit前，查询结果是否改变：

   1. 检测旧MVCC对象版本的读取

      ```
      MVCC在提交时会忽略另一个事务的写入，那么在提交时它的前提已经过时了
      解决：当事务想要提交时，检查是否有任何被忽略的写入现在已经被提交(前提过时)
      ```

      

   2. 检测影响先前读取的写入

      ```
      当事务写数据库时，它必须在索引中查找最近曾经读取受影响数据的其他事务。
      在读取一个row时，如果使用了索引如下shift_id那么就在索引上记录该事务读了数据
      当去修改该索引时，会通知其他在该索引上的事务，你们之前读的数据过期了
      然后第一个在该索引上commit的事务成功，其他事务失败
      下图中，42在set一个新值后通知43读了过期数据
      43在set时也会告诉42它读的值过期了。
      42即使知道自己之前的数据过期了，但发现自己是第一个commit的，就直接提交
      43发现42已经提交了，就abort
      ```

      ![1593858828041](C:\Users\hasaki\AppData\Roaming\Typora\typora-user-images\1593858828041.png)



时钟和时序问题

## 四、分布式系统的问题

### 无法访问的网络

网络可能在任何情况下发生延迟、丢失

### 时钟和单调钟

时钟：Java`System.currentTimeMillis()`，把电脑自动校对时间关闭，往前调一小时再打印发现值会变小

单调钟：`System.nanoTime()`不受调时间影响，精度更高，每个cpu上都有一个单独的计时器，互相之间不一定相等，操作系统协调。

如果用计算机钟的石英钟，Google假设每天重新同步的时钟飘逸为17秒

### 有序事件的时间戳

依赖时钟在多个节点上对事件进行排序，如果可以的话就可以很方便的使用全局快照

Spanner 就是以这种方式实现的。GPS+原子钟，7ms内可以完成同步。它提供了时钟API提供了这个事务的最早时间和最晚时间(误差)。只需要A*{earliest} < A*{latest} < B*{earliest} < B*{latest}就可以保证B一定在A之后。