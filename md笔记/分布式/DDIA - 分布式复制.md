

## 分布式 复制 Replication

优点：

* 使得数据与用户在地理上接近（从而减少延迟） 

* 即使系统的一部分出现故障，系统也能继续工作（从而提高可用性） 

* 扩展可以接受读请求的机器数量（从而提高读取吞吐量）

三种流行的变更复制算法：

* 单领导者（single leader）
* 多领导者  (multi leader)
* 无领导者  (leaderless)

### 一、领导者与追随者

最常见的解决方案被称为基于领导者的复制（**leader-based replication**）（也称主动**/**被动（**active/passive**） 或 主**/**从（**master/slave**）复制）

1. 副本之一被指定为领导者 (leader) ，也成为 主库（master），首要（primary）。当客户端要向数据库写入时，它必须将请求发送给领导者，领导者会将新数据写入其本地存储。
2. 其他副本被称为追随者（followers），亦称为只读副本（read replicas），从库（slaves），次要（sencondaries），热备（hot-standby）。

3. 当客户想要从数据库中读取数据时，它可以向领导者或追随者查询。但只有领导者才能接收写操作。

### 二、同步复制与异步复制

![1582971783488](https://ae01.alicdn.com/kf/H7a68c986f7bb4e62a2fb4483495a026dr.png)

基于领导者的复制：一个同步从库和一个异步从库

同步复制的优点是，从库保证有与主库一致的最新数据副本。如果主库突然失效，我们可以确信这些数据仍然能在从库上上找到。缺点是，如果同步从库没有响应（比如它已经崩溃，或者出现网络故障，或其它任何原因），主库就无法处理写入操作。主库必须阻止所有写入，并等待同步副本再次可用。 

如果同步从库变得不可用或缓慢，则使一个异步从库同步。这保证你至少在两个节点上拥有最新的数据副本：主库和同步从库。 这种配置有时也被称为半同步（**semi-synchronous**）。 

#### 设置新从库

1. 在某一时刻获得主库的一致性快照，而不必锁定整个数据库。大多数数据库都具有这个功能，因为它是备份必须的。对于某些场景，可能需要第三方工具，例如 MySQL 的 innobackupex/
2. 将快照复制到新的从库节点。
3. 从库连接到主库，并拉取快照后发生的所有数据变更。这要求快照与主库复制日志中的位置精确关联。该位置有不同的名称：例如 PostgreSQL 将其称为日志序列号(log sequence number,LSN), MySQL 将其称为二进制坐标（binlog coordinates）。
4. 当从库处理完快照之后积压的数据变更，我们说它赶上（caught up）了主库。现在它可以继续处理主库产生的数据变化了。

#### 处理节点宕机

* 从库失效：追赶恢复

  从库可以从日志中知道，在发生故障之前处理的最后一个事务。

* 主库失效：故障转移

  其中一个从库需要被提升为新的主库，需要重新配置客户端，以将它们的写操作发送给新的主库，其他从库需要开始拉取来自新主库的数据变更。这个过程被称为故障转移（**failover**）。

#### 复制日志的实现

基于主库的复制底层时如何工作的？事件中有好几种不同的复制方式，所以先简要地看一下。

* 基于语句复制

  主库记录下它执行的每个写入请求，并将语句日志发送给其他库。对于关系数据库来说，意味着每个 `insert\update\delete` 语句都转发给每个从库，每个从库解析并执行该 SQL 语句，就像从客户端收到一样。

  缺点：调用非确定函数例如 `NOW()`获得当前日期，或使用`RAND()`获得一个随机数。使用了自增或依赖于数据库中的现有数据，则必须在每个副本上按照完全相同的顺序执行它。

* 传输预写式日志

  对于**日志结构存储引擎（请参阅“SSTables和LSM树”）**，日志是主要的存储位置。日志段在后台压缩，并进行垃圾回收。对于覆写单个磁盘块的**B树**，每次修改都会先写入预写式日志（**Write Ahead Log,** **WAL**），以便崩溃后索引可以恢复到一个一致的状态。 

  在任何一种情况下，日志都是包含所有数据库写入的仅追加字节序列。可以使用完全相同的日志在另一个节点上构建副本：除了将日志写入磁盘之外，主库还可以通过网络将其发送给其从库。 

  缺点：数据与存储引擎耦合度高、不方便运维

* 逻辑日志复制（基于行）

  复制和存储引擎使用不同的日志格式（与存储引擎解耦）MySQL 的二进制日志使用了这个方法（基于行的复制）

  可以很好的做到向后兼容使 leader 和 followers 可以运行不同版本的数据库，外部应用方便解析。

* 基于触发器的复制

  前面都是一些由数据库系统实现的，不够灵活。

  触发器允许注册在数据库系统中发生数据库更改（写入事务）时自动执行的自定义应用程序代码。有机会将更改记录到一个单独的表中，使用外部程序读取这个表，再加上任何业务逻辑处理，会后将数据变更复制到另一个系统去。

  缺点：通常比其他复制方法具有更高的开销，并且比数据库内置的复制更容易出错。

### 三、复制延迟

基于主库的复制要求所有写入都由单个节点处理，但只读查询可以由任何副本处理。所以对于读多写少的场景（Web上的常见模式），一个有吸引力的选择是创建很多从库，并将读请求分散到所有的从库上去。不幸的是，当应用程序从异步从库读取时，如果从库落后，它可能会看到过时的信息。

这种效应被称为最终一致性（**eventually consistency**）

![1582990790467](https://ae01.alicdn.com/kf/H670c601f1b644239846e7d7dbf8f8ea0p.png)

#### **读后一致性**

一些基于领导者的复制系统中实现读后一致性：

* 如社交网络中，每个账号的个人信息只有自己才能修改，于是制定一个规则：读取自己的档案时从主库读，而在从库读别人的档案。

* 如果大部分信息都可以自己修改（算作自己的档案），可以跟踪上次更新的时间，在一次更新后的一分钟内，从主库读或监控从库的复制延迟防止向滞后超过一分钟的从库发出查询。

* 客户端记住最近一次写入的时间戳，系统需要确保从库为该用户提供任何查询时，该时间戳前的变更已经传播到了本从库中。如果没有就是不够新，切换从库或等待或从主库中读。

  还需要考虑的情况为：如果分别在两个设备上使用一个账号就不行，比如在手机上修改然后在电脑上查看

#### **单调读**

用户可能会遇到时光倒流（moving backward in time）

如果用户 1234 写了一个评论，同步至 followers1 中，还没有同步至 followers2 中，这个时候用户 2345 进行两次查询操作，一次访问 followers1 另一次访问 followers2 就可能发生第一次读的到而第二次读不到。

![1582992488635](https://ae01.alicdn.com/kf/H8789e22a1e8845399ccbdfc47809deba8.png)

为了防止这种异常，我们需要 单调读（**Monotonic reads**），这是一个比强一致性更弱，但比最终一致性更强的保证。

实现方法为确保每个用户总是从一个副本进行读取。

#### **一致前缀读**

第三个复制延迟例子违反了因果律。

![1582992837299](https://ae01.alicdn.com/kf/Hde0b74e634d34b4e8821e7eda09dac34V.png)

如果某些分区的复制速度慢于其他分区，那么观察者看的的顺序和初始顺序可能不同。

为了防止这种异常需要另一种保证：一致前缀读（**consistent prefix reads**）这个保证说：如果一系列写入按某个顺序发生，那么任何人读取这些写入时，也会看见它们以同样的顺序出现。 

这是分区（partitioned）数据库中的一个特殊问题。

一种解决方案是，确保任何因果相关的写入都写入相同的分区。

### 四、多主复制

到目前为止，我们只考虑使用单个领导者的复制架构。 虽然这是一种常见的方法，但也有一些有趣的选择。

基于领导者的复制有一个主要的缺点：只有一个主库，而所有的写入都必须通过它。如果出于任何原因（例如和主库之间的网络连接中断）无法连接到主库， 就无法向数据库写入。 

多领导者也是其他领导者的 followers

**应用场景**：在单个数据中心内部使用多个主库很少是由意义的，因为好处很少超过复杂性的代价。但是一些情况下，多活配置也是合理的。

**运维多个数据中心**：多领导者可以在每个数据中心都有主库。在每个数据中心内使用常规的主从复制；

![1582994555555](https://ae01.alicdn.com/kf/H8412b3ae10b04ad5b63f13474e23d03fR.png)

* 性能：用户感觉到的性能会更好，因为每个写操作可以在本地数据中心进行处理，其他数据中心异步复制。
* 数据中心停机：这个肯定更安全。

需要离线操作的客户端、协同编辑

#### 处理写冲突

多领导者复制的最大问题是可能发生写冲突，这意味着需要解决冲突。

![1582995580929](https://ae01.alicdn.com/kf/Hd6fc2576bf844037b8d58e83adf144b7v.png)

#### 同步与异步冲突检测

可以使冲突检测同步 - 即等待写入被复制到所有副本，然后再告诉用户写入成功。但是，通过这样做，您将失去多主复制的主要优点：允许每个副本独立接受写入。如果您想要同步冲突检测，那么您可以使用单主程序复制。

#### 避免冲突

如果应用程序可以确保**特定记录的所有写入都通过同一个领导者**，那么冲突就不会发生。由于多领导者复制处理的许多实现冲突相当不好，避免冲突是一个经常推荐的方法

#### 收敛至一致的状态

* 给每个写入一个唯一的 ID（例如，一个时间戳，一个长的随机数，一个 UUID 或一个键和值的哈希），挑选最高 ID 的写入作为胜利者，并丢弃其他写入。如果使用时间戳，这种技术被称为最后写入胜利（last write wins），但很容易造成数据丢失。
* 为每个副本分配一个唯一的 ID,ID 编号更高的写入具有更高的优先级。这种方法也意味着数据丢失。
* 以某种方式将这些值合并在一起 - 例如，按字母顺序排序，然后连接它们（在上图中，合并的标题可能类似于“B/C”）。 
* 在保留所有信息的显式数据结构中记录冲突，并编写解决冲突的应用程序代码（也许通过提示用户的方式）。 

#### 自定义冲突解决逻辑

作为解决冲突最合适的方法可能取决于应用程序，大多数多主复制工具允许使用应用程序代码编写冲突解决逻辑。该代码可以在写入或读取时执行。

### 五、多主复制拓扑

![1582997185518](https://ae01.alicdn.com/kf/H9b91c29923c648ab8eb492823c61c98eS.png)

最普遍的拓扑是全部到全部（图5-8 [c]），其中每个领导者将其写入每个其他领导。但是，也会使用更多受限制的拓扑：例如，默认情况下，MySQL仅支持环形拓扑（**circular topology**）

在圆形和星形拓扑中，写入可能需要在到达所有副本之前通过多个节点。因此，节点需要转发从其他节点收到的数据更改。为了防止无限复制循环，每个节点被赋予一个唯一的标识符，并且在复制日志中，每个写入都被标记了所有已经通过的节点的标识符。当一个节点收到用自己的标识符标记的数据更改时，该数据更改将被忽略，因为节点知道它已经被处理。 

在全能拓扑中不会出现上述问题及网络中断或节点故障导致的问题但是会出现：

![1582997841855](https://ae01.alicdn.com/kf/H711754cb3b634a3a98a30513a30ac205l.png)

要正确排序这些事件，可以使用一种称为版本向量（**version vectors**）的技术。

### 六、无主复制

我们在本章到目前为止所讨论的复制方法 ——单主复制、多主复制——都是这样的想法：客户端向一个主库发送写请求，而数据库系统负责将写入复制到其他副本。主库决定写入的顺序，而从库按相同顺序应用主库的写入。

一些数据存储系统采用不同的方法，放弃主库的概念，并允许任何副本直接接受来自客户端的写入。最早的一些的复制数据系统是无领导的（**leaderless**），但是在关系数据库主导的时代，这个想法几乎已被忘却。在亚马逊将其用于其内部的Dynamo系统vi之后，它再一次成为数据库的一种时尚架构。

#### 当节点故障时写入数据库

当一个客户端从数据库中读取数据时，它不仅仅发送它的请求到一个副本：读请求也被并行地发送到多个节点。客户可能会从不同的节点获得不同的响应。即来自一个节点的最新值和来自另一个节点的陈旧值。版本号用于确定哪个值更新

#### 读修复和反熵

**读修复（Read repair）**

![1582999761964](https://ae01.alicdn.com/kf/H26090e67114d4bd1afe04812f0a15cd0S.png)

**反熵过程（Anti-entropy process）**

一些数据存储具有后台进程，该进程不断查找副本之间的数据差异，并将任何缺少的数据从一个副本复制到另一个副本。与基于领导者的复制中的复制日志不同，此反熵过程不会以任何特定的顺序复制写入，并且在复制数据之前可能会有显着的延迟。 

#### 读写的法定人数

如果有n个副本，每个写入必须由w节点确认才能被认为是成功的，并且我们必须至少为每个读取查询r个节点。 （在我们的例子中，n = 3，w = 2，r = 2）。只要w + r>n，我们期望在读取时获得最新的值，因为r个读取中至少有一个节点是最新的。

![1583000471266](https://ae01.alicdn.com/kf/Hdbd328e1d4a042f6be93e9a4d894535eD.png)

#### 仲裁一致性的局限性

通常，r和w被选为多数（超过 n/2 ）节点，因为这确保了 w + r> n ，同时仍然容忍多达$n/2$个节点故障。但是，法定人数不一定必须是大多数，只是读写使用的节点交集至少需要包括一个节点。其他法定人数的配置是可能的，这使得分布式算法的设计有一定的灵活性 。

即使在 w + r> n 的情况下，也可能存在返回陈旧值的边缘情况。这取决于实现，但可能的情况包括：

* 使用松散的法定人数 ，w 和 r 落在不同的节点
* 两个写入同时发生，不清楚哪一个先发生。